# -*- coding: utf-8 -*-import osimport sysimport arcpyimport datetimeimport pandasfrom dateutil.parser import parseimport jsonimport numpyimport reimport subprocessdef posix_time(dt_col):    return int((dt_col - datetime.datetime(1970,1,1)) / datetime.timedelta(milliseconds=1)) * 1000def calculate_fov(size, focal_length):    return round(numpy.rad2deg(2 * (numpy.arctan((size / (2.0 * focal_length))))), 0)def camera_model(in_camera):    sensor_width, sensor_height, true_focal_length = 0, 0, 0    if(in_camera == "P4"):        # DJI Phantom 4        sensor_width = 6.20        sensor_height = 4.65        true_focal_length = 3.60    elif(in_camera == "P4RTK"):        # DJI Phantom 4 RTK        sensor_width = 12.80        sensor_height = 9.60        sensor_hres = 5472        sensor_vres = 3648        true_focal_length = 8.86    elif(in_camera == "Mavic2Pro"):        # Mavic 2 Pro Hasselblad - L1D-20c        sensor_width = 13.2        sensor_height = 8.8        true_focal_length = 10.3    return [sensor_width, sensor_height, true_focal_length]def get_subtitles(in_file, out_srt):    if(os.path.exists(out_srt)):        os.unlink(out_srt)    p_gpt = subprocess.Popen(["ffmpeg", "-i", in_file, out_srt, "-hide_banner", "-loglevel", "error"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,                             creationflags=subprocess.CREATE_NO_WINDOW)    stdout, stderror = p_gpt.communicate()    if (len(stderror.decode()) != 0):        return stderror.decode()    else:        return stdout.decode()def parse_srt(in_file):    with open(in_file) as srt:        rows = srt.readlines()        start, end, by = 0, len(rows), 4        for i in range(0, end, by):            yield rows[i:i+by]def get_start_movie_time(in_file):    cmd_ = ["ffprobe", "-print_format", "json", "-show_format", "-export_xmp", " 1", "-hide_banner", "-loglevel", "error", in_file]    p_gpt = subprocess.Popen(cmd_, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,                             creationflags=subprocess.CREATE_NO_WINDOW)    stdout, stderror = p_gpt.communicate()    if(len(stderror.decode()) != 0):        return stderror.decode()    else:        return stdout.decode()def get_rtk_lng_lat(in_str):    lng_, lat_ = [eval(x) for x in in_str[6:-5].split(",")]    return lng_, lat_def get_rtk_alt(in_str):    alt_ = eval(in_str.strip()[1:-1])    return alt_def get_floats_from_string(in_str):    numbers = r"[+-]?\d+(?:\.\d+)?"    # numbers = re.compile("[^-\d]")    return [float(x) for x in re.findall(numbers, in_str)]def get_p_pry(in_str):    p_pitch_, p_roll_, p_yaw_ = get_floats_from_string(in_str)    return p_pitch_, p_roll_, p_yaw_def get_c_pry(in_str):    c_pitch_, c_roll_, c_yaw_ = get_floats_from_string(in_str)    return c_pitch_, c_roll_, c_yaw_def write_header(in_file):    misb_fields = ["UNIX Time Stamp", "Sensor Latitude", "Sensor Longitude", "Sensor Ellipsoid Height", "Platform Heading Angle", "Platform Pitch Angle","Platform Roll Angle", "Sensor Relative Roll Angle", "Sensor Relative Elevation Angle", "Sensor Relative Azimuth Angle", "Sensor Horizontal Field of View", "Sensor Vertical Field of View"]    in_file.write(",".join(misb_fields) + "\n")    in_file.flush()class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [DetectLandslidesFeatures, MapExposureToLandslides, GenerateFMV, GenerateRiskMappingTemplate]class DetectLandslidesFeatures(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Cartografiere alunecare de teren"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = None        sourceType = arcpy.Parameter(            displayName="Sursa date (Foto/Video)",            name="source_type",            datatype="DEFile",            parameterType="Required",            direction="Input")#         sourceType.filter.type = "ValueList"#         sourceType.filter.list = ["Ortofotoplan/Imagine aeriana", "Film geocodat (FMV)"]        dlpkLandslides = arcpy.Parameter(            displayName="Model preantrenat",            name="dlpk_landslides",            datatype="DEFile",            parameterType="Required",            direction="Input")        outResults = arcpy.Parameter(            displayName="Elemente alunecare de teren",            name="out_features",            datatype="DEFeatureClass",            parameterType="Required",            direction="Output")        params = [sourceType, dlpkLandslides, outResults]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.AddMessage("DetectLandslidesFeatures")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass MapExposureToLandslides(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Expunere la aluencari de teren"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = None        sourceType = arcpy.Parameter(            displayName="Sursa date (Foto/Video)",            name="source_type",            datatype="DEFile",            parameterType="Required",            direction="Input")#         sourceType.filter.type = "ValueList"#         sourceType.filter.list = ["Ortofotoplan/Imagine aeriana", "Film geocodat (FMV)"]        dlpkHouses = arcpy.Parameter(            displayName="Model preantrenat detectare cladiri",            name="dlpk_houses",            datatype="DEFile",            parameterType="Optional",            direction="Input")        dlpkRoads = arcpy.Parameter(            displayName="Model preantrenat detectare drumuri",            name="dlpk_roads",            datatype="DEFile",            parameterType="Optional",            direction="Input")        dlpkLandslides = arcpy.Parameter(            displayName="Model preantrenat detectare aluencari",            name="dlpk_landslides",            datatype="DEFile",            parameterType="Optional",            direction="Input")        outResults = arcpy.Parameter(            displayName="Elemente expuse",            name="out_features",            datatype="DEFeatureClass",            parameterType="Required",            direction="Output")        params = [sourceType, dlpkLandslides, dlpkHouses, dlpkRoads, outResults]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.AddMessage("MapExposureToLandslides")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass GenerateFMV(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Generare FMV"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = None        videosPath = arcpy.Parameter(            displayName="Dosar video UAV",            name="videos_path",            datatype="DEFolder",            parameterType="Required",            direction="Input")        telemetryFile = arcpy.Parameter(            displayName="Fisier telemetrie UAV",            name="dlpk_houses",            datatype="DEFile",            parameterType="Optional",            direction="Input")        outResults = arcpy.Parameter(            displayName="Video geocodate",            name="out_features",            datatype="DEFolder",            parameterType="Required",            direction="Output")        params = [videosPath, telemetryFile, outResults]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.AddMessage("Se genereaza filme geocodate")        path_videos = parameters[0].valueAsText        path_telemetry = parameters[1].valueAsText #r"E:\OneDrive - unibuc.ro\SlideMap\Zboruri\An2021\Pietrari_Pietrari_Dambovita\8Octombrie2021\Telemetrie\Phantom4RTK-0uykh8700201e8 10_8_2021 1_28_31 PM (01_09_15).csv"        path_fmvs = parameters[2].valueAsText#         path_telemetry_file4fmv = path_fmvs        os.mkdir(path_fmvs)        path_ugcs_telemtry_file = os.path.dirname(path_telemetry)        telemetry_file_name = os.path.basename(path_telemetry)        path_fmv_metadata_file = os.path.join(path_ugcs_telemtry_file, telemetry_file_name.replace(".csv", "_processed.csv"))        columns_to_keep = ['time', 'longitude', 'course', 'altitude_raw', 'roll', 'latitude', 'vertical_speed',                           'ground_speed',                           'heading', 'pitch', 'gimbal:roll', 'gimbal:pitch', 'gimbal_heading', 'hfov', 'vfov',                           'altitude_amsl', 'altitude_agl', 'TimeStamp']        camera = camera_model(in_camera="P4RTK")        sensor_width = camera[0]        sensor_height = camera[1]        true_focal_length = camera[2]        pd_ugcs = pandas.read_csv(path_telemetry)        pd_ugcs["TimeStamp"] = pandas.to_datetime(pd_ugcs.time).apply(posix_time)        pd_ugcs["hfov"] = calculate_fov(sensor_width, true_focal_length)        pd_ugcs["vfov"] = calculate_fov(sensor_height, true_focal_length)        # pd_ugcs["altitude_amsl"] = pd_ugcs.takeoff_altitude + pd_ugcs.altitude_raw        pd_ugcs["altitude_amsl"] = pd_ugcs["control_server:altitude_amsl"]        pd_ugcs["altitude_agl"] = pd_ugcs["control_server:altitude_agl"]        pd_ugcs["gimbal_heading"] = 0        pd_fmv = pd_ugcs[columns_to_keep]        columns_mapping = {            "time": "Time",            "longitude": "Sensor Longitude",            "course": "Course",            "altitude_raw": "Sensor Altitude Above Ground",            "roll": "Platform Roll Angle",            "latitude": "Sensor Latitude",            "vertical_speed": "Vertical Speed",            "ground_speed": "Ground Speed",            "heading": "Platform Heading Angle",            "pitch": "Platform Pitch Angle",            "gimbal:roll": "Sensor Relative Roll Angle",            "gimbal:pitch": "Sensor Relative Elevation Angle",            "gimbal_heading": "Sensor Relative Azimuth Angle",            "hfov": "Sensor Horizontal Field of View",            "vfov": "Sensor Vertical Field of View",            "altitude_amsl": "Sensor True Altitude",            "altitude_agl": "Sensor True Altitude AGL",            #     "altitude_amsl": "Sensor True Altitude",            "TimeStamp": "UNIX Time Stamp"}        pd_fmv.columns = list(columns_mapping.values())        pd_fmv.to_csv(path_fmv_metadata_file)        pd_telemtry = pandas.read_csv(path_fmv_metadata_file, parse_dates=True)        for mov in os.listdir(path_videos):            name, ext = os.path.splitext(mov)            if(ext.upper() == ".MOV"):                arcpy.AddMessage("Se genereaza filme geocodat pentru fisierul " + mov)                path_video = os.path.join(path_videos, mov)                path_video_srt = os.path.join(path_fmvs, name + ".srt")                path_video_mp = os.path.join(path_fmvs, name + ".ts")                get_subtitles(in_file=path_video, out_srt=path_video_srt)                chunks = list(parse_srt(in_file=path_video_srt))                video_md = json.loads(get_start_movie_time(in_file=path_video))                creation_datetime = parse(video_md["format"]["tags"]["creation_time"])                duration = eval(video_md["format"]["duration"])                end_time = creation_datetime + datetime.timedelta(seconds=duration)                print(mov, creation_datetime, duration, end_time)                s_time_ = creation_datetime.timestamp() * 1000 * 1000                e_time_ = end_time.timestamp() * 1000 * 1000                pd_ = pd_telemtry.loc[lambda x:  (x["UNIX Time Stamp"] <= e_time_) & (x["UNIX Time Stamp"] >= s_time_) ]                path_telemetry_file4fmv = os.path.join(path_fmvs, name + "_4fmv.csv")                pd_.to_csv(path_telemetry_file4fmv, index=False)                pd_ = None                arcpy.ia.VideoMultiplexer(in_video_file=path_video, metadata_file=path_telemetry_file4fmv, out_video_file=path_video_mp, metadata_mapping_file=None, timeshift_file=None, elevation_layer=None)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass GenerateRiskMappingTemplate(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Sablon cartografiere expunere"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = None        workingGDB = arcpy.Parameter(            displayName="Geodatabase",            name="working_gdb",            datatype="DEWorkspace",            parameterType="Required",            direction="Input")        prefixFD = arcpy.Parameter(            displayName="Prefix feature dataset si feature class",            name="prefix_fd",            datatype="GPString",            parameterType="Required",            direction="Input")        params = [workingGDB, prefixFD]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.AddMessage("Se genereaza sablon pentru cartografiere expunere")        path_gdb = parameters[0].valueAsText        prefix = parameters[1].valueAsText        name_fd = prefix + "SlideMap"        path_fd = os.path.join(path_gdb, name_fd)        rapa = prefix + "_rapa"        corp = prefix + "_corp"        cladiri = prefix + "_cladiri"        drumuri = prefix + "_drumuri"        arcpy.management.CreateFeatureDataset(path_gdb, name_fd, arcpy.SpatialReference(3857))        arcpy.management.CreateFeatureclass(path_fd, rapa, "POLYLINE")        arcpy.management.CreateFeatureclass(path_fd, corp, "POLYGON")        arcpy.management.CreateFeatureclass(path_fd, cladiri, "POLYGON")        arcpy.management.CreateFeatureclass(path_fd, drumuri, "POLYLINE")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return